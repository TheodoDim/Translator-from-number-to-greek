<h1>Εργασία_1 Άσκηση_3</h1>

<p>Αυτή είναι η παρουσίαση της λύσης μου για την τρίτη άσκηση της δεύτερης εργασίας στα πλαίσια του μαθήματος <i>Εισαγωγή στον Προγραμματισμό</i> του <i>Εθνικού και Καποδιστριακού Πανεπιστημίου Αθηνών</i> </p>

<p> Για την διεκπαιρέωση αυτής της εργασίας ακολούθησα την τεχνική της αναδρομής, δεδομένου ότι μία λύση χωρίς αναδρομή φαντάζει πολύ δυσκολότερη, αν όχι αδύνατη.</p>

<h3>Αναδρομή: Ένας τρόπος σκέψης</h3>

<p>Η γενική ιδέα είναι η εξής: Έχουμε έναν αριθμό num. Θα προσπαθήσουμε να διασπάσουμε τα ψηφία του σε όλους τους δυνατούς συνδυασμούς. Για κάθε συνδυασμό θα κρατάμε ένα άθροισμα sum και θα ελέγχουμε εάν το άθροισμα είναι ίσο με την ρίζα του αριθμού που εξετάζουμε. Με taken συμβολίζεται το τμήμα του αριθμού που μόλις πάρθηκε και με num ο αριθμός από τον οποίο πήραμε το taken. Tέλος με sum συμβολίζεται το άθροισμα των μέχρι πρότινως taken αριθμών.</p>
<p>Ας πάμε βήμα βήμα να δούμε πως δουλεύει. Ας πάρουμε τον αριθμό 1296, αρχικά παρατηρούμε πως δεν έχει νοήμα να επιλέξουμε κομμάτια του αριθμού με παραπάνω από 2 ψηφία, γιατί κάτι τέτοιο θα μας έβγαζε αυτομάτως πάνω από την ρίζα του αριθμού. Άρα επιλέγουμε κομμάτια μεγέθους 2 ή 1. Ας ξεκινήσουμε παίρνοντας πρώτα κομμάτια 2 ψηφίων ενός αριθμού.</p>
<p></p>

<p>Ακολουθεί ο τρόπος επεξεργασίας από το πρόγραμμα για την συγκεκριμένη περίπτωση του 1296<br>
</p>
   
  
  ```c
taken 96 num 1296 sum 96
// παίρνουμε από το 1296 το 96
taken 12 num 12 sum 108
// παίρνουμε από το 12 το 12
taken 2 num 12 sum 98
// έχουμε μείνει χωρίς επιλογές και με sum != root , πάμε ένα βήμα πίσω στην αναδρομή
//και αυτή την φορά επιλέγουμε κομμάτια μεγέθους 1, αφού οι επιλογές κομματιών μεγέθους 2 δεν μας έβγαλαν κάπου 
taken 1 num 1 sum 99
// επιλέγουμε το τελευταίο κομμάτι μεγέθους 1 του αριθμού
//ούτε αυτό δούλεψε οπότε επιστρέφουμε πάλι ένα βήμα πίσω, δηλαδή στο σημείο
//επιλογής πλέον κομματιών όχι δύο αλλά μίας θέσης από τον 1296
taken 6 num 1296 sum 6
//επομένως αν ξεκινήσουμε παίρνοντας στην αρχή κομμάτι μεγέθους 2 δεν μας βγάζει πουθενά,
//οπότε παίρνουμε κομμάτι μεγέθους 1, δηλαδή παίρνουμε το 6 από το 1296
taken 29 num 129 sum 35
// ξεκινάμε πάλι εδώ παίρνοντας κομμάτια μεγέθους 2, γιατί όταν επεξεργαζόμαστε έναν αριθμό
//πάντα ξεκινάμε με την επιλογή του μέγιστου σε μέγεθος κομματιού
taken 1 num 1 sum 36
// έχει απομείνει το 1 οπότε παίρνουμε ότι μένει και έχουμε φτιάξει sum 36
```
![flawless](https://github.com/progintro/hw1-TheodoDim/assets/62746432/034bafde-3ea1-431e-ae7a-399df98170fa)


<p>Μπορούμε να γενικεύσουμε αυτόν τον τρόπο σκέψης ως εξής. Έχουμε έναν αριθμό num και τον σπάμε όπου μπορούμε να τον σπάσουμε. Ότι απομένει από το σπάσιμο το σπάμε όπου μπορούμε να το σπάσουμε και ούτο καθεξής. Σύμφωνα με αυτή την διαδικασία, μόλις διασπάσουμε όλα τα ψηφία ενός αριθμού με έναν συγκεκριμένο τρόπο, δηλαδή όταν ο εναπομείνων αριθμός num είναι 0 ελέγχουμε αν το τρέχων άθροισμα είναι ίσο με το root. Αν ναι τότε επιστρέφουμε 1 και γίνεται unfold όλο το recursion και γυρίζει το 1 στην main. Αν όχι κάνουμε return 0 ο αλγόριθμος πάει ένα βήμα πίσω και διασπάει τον προτελευταίο αριθμό με όσους άλλους διαφορετικούς τρόπους υπάρχουν. Όλα αυτά γίνονται μέχρι να περατώσει η διαδικασία, δηλαδή μέχρι να εξερευνήσουμε όλους τους δυνατούς τρόπους χωρίς καμία επιτυχία ή να βρούμε άθροισμα στο root. Καίριας σημασίας σε αυτή την προσέγγιση είναι να ανανεώνουμε το sum σε κάθε αναδρομή. Δηλαδή πρέπει να αυξάνουμε το sum κάθε φορά που εξευρενούμε πιο βαθιά το δένδρο των συναδυασμών, αλλά και να αφαιρούμε το τελευταίο αντικείμενο που προσθέσαμε όταν πηγαίνουμε ένα βήμα πίσω.</p>
<p>Ακόμη ένα optimisation που μπορούμε να κάνουμε είναι να πηγαίνουμε ένα βήμα πίσω στην αναδρομή κάθε φορά που έχουμε δημιουργίσει άθροισμα μεγαλύτερο του root, αφού σε αυτή την περίπτωση γνωρίζουμε με απόλυτη σιγουριά ότι έχουμε παρεκλίνει από το ορθό μονοπάτι(εάν αυτό υπάρχει).</p>

<p>Αυτό το optimisation υλοποιείται μέσω του εξής ελέγχου:</p>


```c
// επιστροφή ένα βήμα πριν στην αναδρομή αν έχουμε ξεπεράσει την ρίζα
if (sum_f > root) {
    return 0;
  }
```
<p>Πρέπει να σημειωθεί πως η συνάρτηση flawless απλά επιστρέφει στην main 1 εάν ο αριθμός είναι flawless και 0 σε κάθε άλλη περίπτωση. Ακόμη η flawless δέχεται σε κάθε κλήση της 3 ορίσματα. Το πρώτο num είναι ο αριθμός που εξετάζει στην συγκεκριμένη αναδρομή. Το δεύτερο είναι η ρίζα στόχος που θέλουμε να δημιουργήσουμε μέσω αθροισμάτων. Τέλος το τρίτο είναι το sum που έχει σχηματίσει μέσω των διάφορων αναδρομικών κλήσεων. Ακόμη οφείλω να αναφέρω πως η συνάρτηση flawless για οποιονδήποτε αριθμό ανεξαρτήτου μεγέθους εξερευνεί τους τρόπους που μπορούμε να εξευνήσουμε έως και το πόλυ 7 ψηφία του. Αυτό γίνεται γιατί μετά από εκτενές testing κατέληξα στο ότι δεν άξιζε χρονικά να υπολογίζω το πλήθος των ψηφίων ενός αριθμού σε κάθε κλήση της flawless από το loop της main. Για να μπορώ να ελέγχω πόσα ψηφία θέλω να διασπάσω από έναν αριθμό, δημιούργησα μια δική μου συνάρτηση power που δοθέντος ενός ορίσματος i επιστρέφει το 10 ^ i. Έφτιαξα την δική μου έκδοση της pow, προκειμένου να μην κάνω συνέχεια προβληματικά castings σε int σε κάθε αναδρομή.</p>

<p>Η υλοποίηση της power: </p>


```c
long long int power(int i) {
  int ans = 1, j;
  for (j = 0; j < i; j++) {
    ans = ans * 10;
  }
  return ans;  // υπολογισμός του 10^i
}
```

<p>Παρακάτω παρατίθεται ο κώδικας της αναδρομικής συνάρτησης flawless.</p>

```c
int flawless(long long int num, long long int root, long long int sum_f) {
  long long int taken, i, a;
  if (num == 0) {
    if (sum_f == root) {
      return 1;  // επιστροφή 1 σε περίπτωση ταύτισης
    }
    return 0;
  }
  // επιστροφή ένα βήμα πριν στην αναδρομή αν έχουμε ξεπεράσει την ρίζα
  if (sum_f > root) {
    return 0;
  }
  for (i = 7; i >= 1; i--) {
    a = power(i);  // υπολογισμός του  10 ^ i
    taken = num % a;  // απομόνωση του πρώτου από δεξιά κομματιού i ψηφίων
    sum_f += taken;  // αύξηση του αθροίσματος κατά του αριθμού που επιλέχθηκε
    if (flawless(num / a, root, sum_f)) {
      return 1;
    }
    sum_f = sum_f - taken;  // ανανέωση sum_f επιστροφή στην προηγούμενη κλήση
  }
  return 0;  // επιστροφή 0 αν εξαντληθούν οι περιπτώσεις χωρίς επιτυχία
}
```


<h3>Τμήμα main: Καιρός να καλέσουμε την flawless!</h3>
<p>Στην άσκηση flawless, όπως και στην mirror δεν θα ελέγχουμε για τέλεια τετράγωνα, αλλά θα τα δημιουργούμε εμείς! Επομένως πρέπει πάλι να αλλάξουμε τα low και τα high μέσα στο loop που τρέχουμε.</p>

<p>Συνοπτικά η επεξεργασία των ορισμάτων low, high γίνεται με τον ακόλουθο τρόπο: </p>

```c
i = ceil(sqrt(low));
high = sqrt(high);
```
<p>Τώρα που έχουμε έτοιμα τα άνω και κάτω όρια πρέπει να φτιάξουμε το loop που καλεί την flawless. Σε κάθε αριθμό i που κάνουμε iterate από τα αλλαγμένα πλέον άνω και κάτω όρια, υπολογίζουμε το τετράγωνο του j. Οπότε προφανώς ο j θα είναι τέλειο τετράγωνο, όπως γίνεται illustrate και στην δεύτερη άσκηση της εργασίας. Με τα τέλεια τετράγωνα έτοιμα το μόνο που μας λείπει τώρα είναι να τα περάσουμε στην flawless. Από το θεώρημα που αποδείξαμε από κάτω καλούμε την flawless με όρισμα τα j , i και 0 μόνον αν j % 9 == $\sqrt{j}$ % 9. Αν επιστρέψει η συνάρτηση 1, τότε αυξάνουμε το άθροισμα των flawless αριθμών κατά j. Μετά το πέρας του κύριου loop της main εκτυπώνουμε το αποτέλεσμά μας.</p>
<h3>Modulo_9: Η απόδειξη</h3>
<p>Κατά την ανάγνωση των αριθμών flawless και των αντίστοιχων ριζών τους μπορεί κανείς να παρατηρήσει πως οι ρίζες τους κάτι έχουν να κάνουν με το 9. Παρακάτω δίνονται οι πρώτοι 10 flawless αριθμοί και δίπλα οι ρίζες τους.</p>

```c
1 1
81 9
100 10
1296 36
2025 45
3025 55
6724 82
8281 91
10000 100
55225 235
```
<p>Αρχικά παρατηρούμε ότι για τους μισούς σχεδόν αριθμούς οι ρίζες τους είναι πολλαπλάσια του 9 και οι υπόλοιπες μισές απέχουν λίγο απο πολλαπλάσιο του 9. Είναι πλέον προφανές ότι οι αριθμοί αυτοί κατά κάποιον τρόπο σχετίζονται με το 9. Ας δούμε τι μπορούμε να αποδείξουμε με αυτή την παρατήρηση: </p>


![flawless_proof](https://github.com/progintro/hw1-TheodoDim/assets/62746432/e4b75b45-a5b6-47c7-ba3e-d9b5a8be5955)

<p>Προσέξτε το εξής: Με αυτή την απόδειξη δείξαμε πως εάν ένας αριθμός num είναι flawless τότε num % 9 == $\sqrt{num}$ % 9. Παίρνοντας τον αντιθετοανάστροφο αυτής της πρότασης έχουμε πως αν !(num % 9 == $\sqrt{num}$ % 9) τότε ο num σίγουρα δεν είναι flawless. Επομένως, συμπεραίνουμε πως έχει νοήμα να εξετάζουμε εάν ο αριθμός num είναι flawless εάν πληρείται η συνθήκη num % 9 == $\sqrt{num}$ % 9, χωρίς όμως η αλήθεια της προηγούμενης έκφρασης να συνεπάγεται πως ο num είναι flawless.</p>


<h3>Τελικές Παρατηρήσεις - Αδιεκπαιρέωτα ζητήματα</h3>
   <ul>
      <li>Σημαντικές ιδιότητες και ιδέες για την απόδειξη του flawless άντλησα από το https://www.geeksforgeeks.org/modular-arithmetic/</li>
      <li>Η συνάρτηση flawless κάνει πολλές άχρηστες επαναλήψεις. Συγκεκριμένα για κάθε αριθμό ελέγχει όλες τις ακολουθίες 7 στοιχείων, ακόμη και αν έχουμε αριθμούς με λιγότερα από 7 ψηφία. Σε αυτή την προσέγγιση κατέληξα διότι μετά από διάφορα test , είδα ότι αυτός ο τρόπος είναι προτιμότερος από το να υπολογίζω το πλήθος των ψηφίων κάθε αριθμού για κάθε επανάληψη. Ενδεχομένως όμως να γίνεται και με πιό έξυπνο τρόπο.</li>
   </ul>
