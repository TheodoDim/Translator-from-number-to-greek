# Dimilion
<h1> Collatz Conjecture - Ακολουθία των Συρακουσών</h1>
<p>Αυτή είναι μια παρουσίαση της λύσης μου για το collatz conjecture, ως μέρος της εργασίας_0 στα πλαίσια του μαθήματος Εισαγωγή στον Προγραμματισμό του τμήματος <i>Πληροφορικής και Τηλεπικοινωνιών του 
  Εθνικού και Καποδιστριακού Πανεπιστημίου Αθηνών</i>. Στην παρουσίαση αυτή περιέχονται διάφορα μεγάλα ή μικρά optimizations τόσο μαθηματικά όσο και αλγοριθμικά που έκανα στην πορεία μου για τον περιορισμό των χρόνων εκτέλεσης.</p>

<p>Στην πορεία μου αυτή πέρασα από μια σειρά διαφορετικών προγραμμάτων των οποίων οι τεχνικές και ο τρόπος λειτουργίας παρατείθονται παρακάτω.
 <ol>
   <li> Πρόγραμμα με <i><b>while</b></i></li>
   <li> Πρόγραμμα με <i><b>recursion</b></i></li>
   <li> Πρόγραμμα με <i><b>recursion και memoization</b></i></li>
   <li> <b>Enhanced</b> πρόγραμμα με <i><b>while και memoization</b></i> <== Τελική Υποβολή</li>

 </ol>
 <p>Πρωτoύ γίνει παρουσίαση των διάφορων τρόπων λύσης είναι αναγκαίο να γίνουν ορισμένες μαθηματικές παρατηρήσεις και παραδοχές</p>
  <ol>
    <li>Προκειμένου να φτάσει ένας αριθμός n της ακολουθίας στο 1 είναι απαραίτητο να μπεί στην κυκλική ακολοθία 1->2->4 και 4->2->1, η οποία μάλιστα είναι και η μόνη κυκλική ακολουθία που έχει μέχρι
    πρότινως εντοπισθεί για το Collatz Conjecture</li>
    <li>Δεν μπορούμε να έχουμε δύο διαδοχικούς περιττούς αριθμούς σε ακολουθία Collatz. Kάθε αριθμός 3n+1 είναι άρτιος για nεN, ιδιότητα που μας βοηθάει να μειώσουμε τον αριθμό των υπολογισμών και των βημάτων</li>
    <li>Οι αριθμοί εκείνοι που είναι δυνάμεις του 2 έχουν μήκος ακολουθίας log2(N)+1 (λογάριθμος του 2 +1)</li>
  </ol>
  
 <h3>1η Προσέγγιση: Πρόγραμμα με απλό while</h3>

 <p>Ουσιαστικά ο απλούστερος τρόπος επίλυσης του προβλήματος. Επιλέγοντας κάθε αριθμό n ανάμεσα στο lower_bound και το upper_bound που δίνοται ως ορίσματα από το command line με ένα απλό iteration με 
 for loop εφαρμόζουμε τον αλγόριθμο του Collatz σε κάθε αριθμό n. Όσο ο αριθμός n δεν γίνεται 1 κρατάμε έναν μετρητή για το πλήθος των βημάτων που απαιτούνται για φτάσουμε στον άσσο. Μετά από κάθε υπολογισμό
 των βημάτων και τερματισμό της ακολουθίας συγκρίνουμε τον μετρητή με την τρέχουσα μεγαλύτερη σε μήκος ακολουθία collatz, η οποία συμβολίζεται με max. Αξίζει να σημειωθεί πως ως αρχική τιμή για την μεταβλητή
 max ορίζεται η τιμή -1. Η προσέγγιση αυτή, αν και χρονικά περίπλοκη αποτελεί σε γενικές γραμμές την ραχοκοκαλιά και των παρακάτω προσεγγίσεων</p>

 <p>Σύντομα παρατίθεται ο κώδικας της τρίτης υλοποίησης</p>
     
  ``` c  
   for(i=lower_bound; i<=upper_bound; i++)
   { 
     while(num!=1)
     {
       if(num%2==0)
       {
         num=num/2;
       }
       else
       {
          num=3*num+1;
       }
       count++;
     }
     if(count > max)
     {
            max=count;
     }
} 
```
 <h3>2η Προσέγγιση: Πρόγραμμα recursion</h3>

 <p>Η ακολουθία του Collatz αποτελεί κλασσικό παράδειγμα προβλημάτος που η επίλυση του μπορεί να προέλθει από την επίλυση επιμέρους απλούστερων προβλημάτων και του συνδυασμού των λύσεων αυτών. Άλλωστε στην ίδια
 κατηγορία συμπέφτουν και άλλα προβλήματα όπως ο υπολογισμός αριθμών Fibonacci ή του παραγοντικού. Με παρόμοιο τρόπο λοιπόν που υλοποιήθηκε ο υπολογισμός παραγοντικού μέσω αναδρομής στην δεύτερη διάλεξη με 
 τον κύριο Αυγερινό, μπορούμε και εμείς να προσεγγίσουμε το Collatz Conjecture. Έτσι δημιουργούμε μια αναδρομική συνάρτηση που παίρνει ως όρισμα έναν αριθμό num. Ως base case ορίζουμε πως εάν num==1 τότε
 return 1. Για κάθε άλλη περίπτωση πριν προσεγγίσουμε το 1 εφαρμόζουμε την ακολουθία Collatz. Συγκεκριμένα εάν num%2==0 δηλαδή ο αριθμός num είναι άρτιος κάνουμε return 1+ collatz(num/2). Στην άλλη περίπτωση που
 ο αριθμός είναι περιττός απλά κάνουμε return 1 + collatz(3*num+1)</p>

<h5>Σύντομα παρατίθεται ο κώδικας της δεύτερης υλοποίησης</h5>

  ```c
int collatz(long long int num){
    if(num==1)
    {
        return 1;
    }
    else if(num%2==0)
    {
        return 1+collatz(num/2);
    }
    else
    {
       return 1+collatz((3*num+1));
       //return 2+collatz((3*num+1)/2);
    }
  }
```
<p>Και η αναδρομική συνάρτηση collatz καλείται μέσω της main ως εξής: </p>

  
```c
 for(i=lower_bound; i<=upper_bound; i++)
        {
           count=recur(i);
           if(count > max)
           {
            max=count;
           }
        }
```
<p>Αξιοποιώντας την δεύτερη παρατήρηση που παρατίθεται στην αρχή της σελίδας παρατηρούμε ότι μπορούμε να μειώσουμε δραστικά της κλήσεις της συνάρτησης collatz, εάν όταν συναντάμε περιττό αριθμό ,αντί να υπολογίζουμε
την ακολουθία για τον αριθμό 3*num+1 την υπολογίζουμε για τον (3*num+1)/2 παραλείποντας δηλαδή ένα βήμα που ήταν δεδομένο ότι θα έπρεπε να περάσουμε. Εφαρμόζοντας αυτή την τεχνική θα πρέπει όμως να επιστρέφουμε
2+recur((3*num+1)/2), που το +1 προκύπτει από το βήμα εκείνο που προσπεράσαμε.</p>

  <h3>3η Προσέγγιση: Πρόγραμμα με recursion και memoization</h3>

  <p>Μετά την ερφαρμογή της ακολουθίας Collatz με το χέρι σε διάφορα παραδείγματα συνειδητοποίησα το εξής: Συνέχεια ασχολούμαστε με τους ίδιους αριθμούς. Οι ίδιοι αριθμοί και ακολουθίες
  επανεμφανίζονται συνεχώς κατά των υπολογισμό των βημάτων ενός αριθμού προς τον άσσο. Γι' αυτό και θα πρέπει προκειμένου να μην κάνουμε περιττούς υπολογισμούς δημιουργήσουμε μια δομή δεδομένων
  στην περίπτωση μας ένα array που θα υπολογίζει πόσα βήματα χρειάστηκε ο αριθμός num να φτάσει στο 1 και θα συμβολίζεται ως memo[num]. Έτσι εάν γνωρίζω ότι το 100 χρειάζεται x iterations μέχρι 
  να φτάσει στο 1 είναι προφανές ότι το 200 θα χρειάζεται x+1 iterations. Και έτσι καταφέρνουμε να υπολογίσουμε το πλήθος βημάτων του 200 χωρίς καν να κάνουμε πράξεις(σχεδόν)! Πρόκειται λοιπόν για 
  την χρήση δυναμικού προγραμματισμού, προκειμένου να επωφεληθούμε απο προηγούμενες τιμές που υπολογίσαμε. Η υλοποίηση είναι η ίδια με μόνη διαφορά πως κάθε φορά που καλούμε την αναδρομική συνάρτηση
  collatz το τελικό αποτέλεσμα της συνάρτησης αποθηκεύεται στην θέση i του πίνακα όπου i ο αριθμός πάνω στον οπόίο εφαρμόζαμε την ακολουθία Collatz. Ακόμη τρποποίησης χρήζει και η συνάρτηση collatz
  έτσι ώστε να μπορεί να καταλαβαίνει εάν μπορεί η όχι να ανακτήσει μια προηγουμένως υπολογσμένη τιμή του πίνακα. Στο πρόγραμμά μας ορίζουμε έναν πίνακα memo 100.000.000 θέσεων με όλες τις αρχικές τιμές 
  μηδενισμένες. </p>

  <p>Σύντομα παρατίθεται ο κώδικας της αρχικής υλοποίησης</p>

  ```c
int collatz(long long int num)
{
      if(num%2==0)
      {
          if(num<=100000000 && memo[num]!=0)
          {
              return memo[num];
          }
          else
          {
              return 1+collatz(num/2);
          }
      }
      else
      {
        if(num<=100000000 && memo[num]!=0)
        {
          return collatz[num];
        }
        else
        {
           return 2+collatz((3*num+1)/2);
        }
      }
  }
  ```
  <p>Και η αναδρομική συνάρτηση collatz καλείται μέσω της main ως εξής: </p>
  
     
  ```c
        for(i=lower_bound; i<=upper_bound; i++)
        {
           count=memo[i]=recur(i);
           if(count > max)
           {
            max=count;
           }
        }
```

<h3>Enhanced πρόγραμμα με while και memoization</h3>
<p>Πρόκειται για την τελευταία έκδοση του προγράμματος που αποτέλεσε και την τελική μου υποβολή, αφού δεν μπόρεσα να βρω καμία επιπλέον βελτιστοποίηση.</p>
<p>Το πρόγραμμα σε γενικές γραμμές ακολουθεί περίπου την ίδια φιλοσοφία με τα προηγούμενα, πλην μερικών μικρών αλλά χρονικά σημαντικών αλλαγών. Καταρχήν η αναδρομική συνάρτηση collatz υλοποιήται πλέον μέσω βρόχου while, ο οποίος φαίνεται να είναι πιο γρήγορος και να έχει μικρότερες απαιτήσεις μνήμης από την αναδρομική προσέγγιση. Ακόμη η συνθήκη της while είναι το 1 και συνεπώς είναι πάντοτε αληθής, οπότε βασιζόμαστε σε συγκεκριμένα break statements που τερματίζουν αυτόν τον φαινομενικά ατέρμων βρόχο. Συγκεκριμένα το πρόγραμμα τερματίζει μόλις βρει έναν άρτιο αριθμό του οποίου τα βήματα προς το 1 έχουν ήδη υπολογιστεί. Επιπλέον σημαντική βελτιστοποίηση αποτελεί το γεγονός ότι σε αυτή την έκδοση του προγράμματος τα βήματα Collatz υπολογίζονται από το 2 μέχρι και το upper_bound, αντί για από το lower_bound μέχρι το upper_bound. Επειδή αυτή η προσέγγιση δεν θα μπορούσε να ενσωματώσει την εύρεση των μέγιστων βημάτων λόγω διαφορετικού εύρους αριθμών εντός του βασικού βρόχου for, η διαδικασία αυτή πραγματοποιείται εκτός του κύριου βρόχου for. Τέλος καίριας σημασίας
είναι και η αλλαγή των συνθηκών υπό τις οποίες το πρόργαμμα αντλεί προηγούμενες τιμές βημάτων. Στην τελευταία έκδοση βλέπουμε ότι χρησιμοποιείται η εντολή num μικρότερο i αντι για num μικρότερο ή  ίσον 100.000.000 και memo[num]!=0. Αυτός έλεγχος αρκεί για την περίπτβση μας διότι γνωρίζουμε ότι για σε κάθε θέση του array που είναι μικρότερη από το i πρέπει ήδη να έχει καταχωρηθεί ένας αριθμός βημάτων, αφού ελέγχουμε τους αριθμούς σειρακά από το 2!(Να σημειωθεί πως ως πριν τους βρόχους γίνεται η εντολή ανάθεσης memo[1]=1;) </p>

<h5>Σύντομα παρατίθεται ο κώδικας της τελικής υλοποίησης</h5>

``` c
   for(i=2; i<=upper_bound; i++)
        {
           count=0;
           num=i;
           while(1)
           {
              if(num & 1)
              {
                 num=(3*num+1);
                 num>>=1;
                 count=count +2;
              }
              else
              {
              num>>=1;
              if(num<i)
                   {
                       count=count+memo[num]+1;
                       break;
                   }
                   
              count++;
            } 
          }
          memo[i]=count;
       }
```
<p>Η εύρεση του μέγιστου αριθμού βημάτων πραγματοποιείται μέσω του κατώθι βρόχου. Προσέξτε πως εάν κρατούσαμε απαρράλακτη την διαδικασία εύρεσης max στην τελευταία έκδοση υπάρχει η πιθανότητα να λάβουμε λάθος αποτέλεσμα στην σπάνια αλλά όχι απίθανη περίπτωση που υπάρχει ένας αριθμός μικρότερος του num που παράγει μεγαλύτερη σε μήκος ακολουθία Collatz από κάθε άλλο αριθμό εντός του εύρους [lower_bound,upper_bound].</p>

```c
  for(i=lower_bound; i<=upper_bound; i++)
    {
       if(max<memo[i])
       {
        max=memo[i];
       }
    }
```


  <h1>Τελικές παρατηρήσεις - αδιεκπαιρέωτα ζητήματα</h1>
   <ul>
     <li>Κατά την δημιουργία του πίνακα για να εφαρμόσω το memoization παρατήρησα το εξής: Πολλοί αριθμοί και μάλιστα διαδοχικοί είχαν ακριβώς τον ίδιο αριθμό βημάτων προκειμέμου να φτάσουν στο 0.
     Πιθανώς να υπάρχει κάποιο μοτίβο ανάμεσα στους αιρθμούς για να μην κάνουμε τζάμπα παραπάνω υπολογισμούς</li>
     <li>Οι αριθμοί στα βήματα της ακολουθίας Collatz αυξάνονται εκθετικά μετά από έναν βαθμό με αποτέλεσμα να γίνεται overflow στην μεταβλητή int που αποθηκεύουμε αυτούς τους αριθμούς.
     Γιανα αποφύγουμε αυτό το πρόβλημα μία γρήγορη λύση είναι να να χρησιμοποιούμε long long int μεταβλητή για να καρατάμε τους αριθμούς. Ωστόσο η χρήση μεταβλητών 64 bit καθυστερεί το πρόγραμμα αισθητά
     ~1 sec λόγω της μεταγλώττισης με -m32. Πιθανώς να μην είναι απαραίτητο να χρησιμοποιούμε long long int μεταβλητές. Μια προσέγγιση θα ήταν κάθε φορά που εξετάζουμε τν ακολουθία για έναν αριθμό num
     να κρατάμε τον num απαρράλακτο και να δημιουργήσουμε έναν πολλαπλασιαστή π.χ. multi τέτοιο ώστε multi*num=τρέχων αριθμός ακολουθίας Collatz. </li>
   </ul>
  


 
