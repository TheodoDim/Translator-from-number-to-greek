<h1>Εργασία_1 Άσκηση_2</h1>

<p>Αυτή είναι η παρουσίαση της λύσης μου για την δεύτερη άσκηση της δεύτερης εργασίας στα πλαίσια του μαθήματος <i>Εισαγωγή στον Προγραμματισμό</i> του <i>Εθνικού και Καποδιστριακού Πανεπιστημίου Αθηνών</i> </p>

<p> Για την διεκπαιρέωση αυτής της εργασίας ακολούθησα τις αρχές του τμηματικού προγραμματισμού, δημιουργώντας μια συλλογή από τρεις συναρτήσεις, προκειμένου να σχηματίσω ένα ευανάνωστο και κατανοητό πρόγραμμα</p>

<h2>Συναρτήσεις που χρησιμοποιήθηκαν</h2>

<ul>
     <li> int64_t mirror(int64_t num)</li>
     <li> int32_t is_prime(int32_t num)</li>
     <li> int32_t perf_mir(int64_t num)</li>
</ul>

<p>Οι λετουργίες τους παρατείθονται σύντομα παρακάτων</p>


<h3>Συνάρτηση 1η : int64_t mirror(int64_t num)</h3>

Η υλοποίηση της συνάρτησης mirror :
```c
int64_t mirror(int64_t num) //συνάρτηση mirror επιστρέφει το κατοπτρικό ενός ακεραίου
{
    int64_t new_num=0, cnt=1;
    while(num!=0) //επεξεργάζεται τον num όσο δεν είναι 0 
    {
        new_num= new_num * 10 + num % 10; //λαμβάνει το τελευταίο ψηφίο του num και χτίζει τον κατοπτρικό
        num=num/10; //διώχνει το τελευταίο ψηφίο του num
        cnt=cnt*10; //αυξάνει τον πολλαπλασιαστή για την δημιουργία του new_num
    }
    return new_num;
}
```

<p>Η λειτουργία της συνάρτησης mirror είναι απλή. H συνάρτηση δέχεται ως όρισμα έαν ακέραιο τύπου int64_t και επιστρέφει τον κατοπτρικό του αριθμού που δέχτηκε πάλι σε τύπο int64_t. Ο αλγόριθμος λειτουργεί ως εξής:
Αρχικά είναι προφανές ότι για να επιστρέψουμε τον κατοπτρικό πρέπει να διασπάσουμε τον αρχικό αριθμό. Γι' αυτό και δημιουργούμε ένα while που επεξεργάζεται το αρχικό αριθμό num, όσο εκείνος δεν έιναι 0. Σε κάθε επανάληψη απομονώνουμε το τελευταίο ψηφίο του num και έπειτα διαρούμε τον num με 10. Έτσι καταφέρνουμε να διασπάσουμε τον αριθμό στα ψηφία που τον αποτελούν.Το μόνο που μένει πλέον είναι καθώς υπολογίζουμε αυτά τα ψηφία να τα συνδυάζουμε με τον κατάλληλο τρόρπο.</p>
<p> Παρατηρούμε πως ο αριθμός 1467 μπορεί να γραφεί ως εξής: 1467 = 1 * 1000 + 4 * 100 + 6 * 10 + 4 Έχοντας διασπάσει τα ψηφία του σε 7 6 4 1, αρκεί να αθροίσουμε τα γινόμενα του αντίστοιχου αριθμού επί την το 10 στην (αύξοντας αριθμός ψηφίου - 1)</p>

<p>Δηλαδή το 7641(που είναι το κατοπτρικό του αρχικού num) γράφεται ως εξής: 7641 = 7 * 10^(4-1) + 6 * 10^(4-2) + 4 * (4-2) + 1 * 10^(4-4)</p>

<h3>Συνάρτηση 2η : int32_t is_prime(int32_t num)</h3>

Μια σύντομη υλοποίηση της συνάρτησης is_prime :

```c
int32_t is_prime(int32_t num) // συνάρτηση is_prime επιστρέφει εάν ένας αριθμός είναι πρώτος ή όχι
{
    int64_t i;
    for(i=2; i<=(int32_t)sqrt(num); i++) // ελέγχει για ακέραιους διαιρέτες μέχρι και την ρίζα του αριθμού 
    {                                    //για περισσότερο insight ανατρέξτε στο readme για μια γρήγορη μαθηματική απόδειξη
        if(num % i == 0)
        {
            return 0; // επιστρέφει 0 αφού ο αριθμός δεν είναι πρώτος και τερματίζει την συνάρτηση
        }
    }
    return 1; // επιστρέφει 1, διότι αν ήταν δεν ήταν πρώτος θα είχε τερματίσει ήδη ο βρόχος από πάνω
}
```

<p>Η συνάρτηση is_prime λειτουργεί ως εξής: Δέχεται ένα όρισμα τύπου int32_t(στην συνάρτηση αυτή δεν χρειάζεται int64_t γιατί δέχεται τις ρίζες των αριθμών και όχι τους ίδιους τους αριθμούς) και επιστρέφει πάλι μια ακέραια τιμή τύπου int32_t που είναι το 1 στην περίπτωση που o αριθμός num είναι πρώτος και 0 σε κάθε άλλη περίπτωση.</p>

<p>Γισ νσ ελέγξουμε εάν ένας αριθμός είναι πρώτος ή όχι αρκεί να ελέγξουμε εάν διαιρείται από κάποιον άλλο αριθμό. Το θέμα είναι ποιό είναι το ελάχιστο εύρος αριθμών που αρκεί να ελέγξουμε για να μπορούμε να συμπεράνουμε με σιγουριά εάν ένας αριθμός είναι πρώτος ή όχι. Η απάντηση σε αυτό το ερώτημα είναι [ 2 , (int32_t)sqrt(num) ].</p>

<p>Μία γρήγορη μαθηματική απόδειξη:</p>

Ας πούμε πως θέλουμε να συμπεράονουμε εάν ο αριθμός num είναι πρώτος ή όχι.

Έστω τώρα ότι υπάρχει ένας ακέραιος αριθμός k ο οποίος είναι διαιρέτης του num και ταυτόχρονα να είναι  μεγαλύτερος του sqrt(num).

Από τα παραπάνω προκύπτουν οι εξής σχέσεις
<ul>
  <li>num = k * l , όπου l ένας άλλος ακέραιος αριθμός (1)</li>
  <li> k > sqrt(num) (2)</li>
</ul>

<p>Θα δείξουμε τώρα ότι το l είναι υποχρεωτικά μικρότερο του sqrt. Έστω ότι δεν ίσχυει αυτό και έχουμε πως l >= sqrt(num)(3).
Tότε πολλαπλασιάζοντας τις σχέσεις (2), (3) θα είχαμε l * k > num, δηλαδή από την (1) num > num άτοπον. </p>

<p>Προσοχή! Στο παραπάνω θεώρημα αποδείξαμε πως δεν έχει νόημα να αναζητούμε για διαρέτες ενός αριθμού πέρα από την ρίζα του γιατί εάν υπήρχαν θα τους είχαμε ήδη βρει προηγουμένως. Σε καμία περίπτωση δεν ισχύει ότι δεν υπάρχουν διαιρέτες ενός αριθμού πέρα από την ρίζα του π.χ το 25 διαιρεί το 100. </p>

<h3>Συνάρτηση 3η : int32_t perf_mir(int64_t num)</h3>

Μια σύντομη υλοποίηση της συνάρτησης perf_mir :

```c
int32_t perf_mir(int64_t num) // συνάρτηση perf_mir ελέγχει αν ένα κατοπτρικό είναι τέλειο και έχει πρώτη ρίζα
{
    double root;
    root=sqrt(num); // υπολογισμός της ρίζας του num
    if(root == (int64_t)root && is_prime((int64_t)root)) // έλεγχος εάν το ακέραιο είναι ίσο με το πραγματικό format της ρίζας
    {                                                   // του num και ταυτόχρονος έλεγχος για το εάν η ρίζα είναι πρώτη
        return 1;
    }
    return 0;
}
```

<p>Η συνάρτηση perf_mir λειτουργεί ως εξής δέχεται ένα όρισμα τύπου int64_t(που είναι ο κατοπτρικός του αριθμού που μελετάμε στην main) και επιστρέφει 1 στην περίπτωση που ο αριθμός που δέχθηκε ως όρισμα είναι και τέλειο τετράγωνο και η ρίζα του είναι και αυτή πρώτος αριθμός. Προκειμένου να πραγματοποιήσει αυτή την λειτουργία η συνάρτηση αξιοποιεί την συνάρτηση is_prime. Ας δούμε πως δουλεύει ακριβώς. Για να αντιληφθούμε εάν ένας αριθμός είναι τέλειος αρκεί να δείξουμε ότι η ρίζα του είναι ακέραιη. Για να δείξουμε ότι μία ρίζα είναι ακέραιη αρκεί να δείξουμε ότι η δεκαδική της αναπαράσταση ισούται με την ακέραια της αναπαράσταση. Γι' αυτό και μέσα στην συνάρτηση αποθηκεύουμε την ρίζα του αριθμού num σε μία μεταβλητή double και έπειτα στο if ελέγχουμε εάν η ρίζα της σε double μορφή ισούται με την casted σε  int64_t ρίζα της. Εάν αυτό ισχύει τότε μπορούμε με σιγουρία να πούμε ότι ο ακέραιος είναι τέλειος.</p>

<p>Σε ότι αφορά το άλλο κομμάτι, δηλαδη η ρίζα να είναι πρώτος αριθμός μπορούμε απλά να προσθεσουμε με ένα && στο if την συνθήκη is_prime((int64_t)root), κάνοντας utilise το τμήμα κώδικα που έχουμε ήδη περιγράψει. Προσοχή! Είναι αναγκαίο να περαστεί ως όρισμα στην is_prime το casted σε int64_t root, δεδομένου ότι η is_prime από τον ορισμό της δέχεται ορίσματα τύπου int64_t</p>


<h2>Τμήμα main: Καιρός να τα συνδυάσουμε όλα!</h2>

<p>Έχοντας υλοποιήσει τις συναρτήσεις που αποτελούν την ραχοκοκαλιά του προγράμματος μας, αρκεί πλέον να τις συνδυάσουμε με τέτοιο τρόπο ώστε να έχουμε τα επιθυμητά αποτελέσματα.</p>
<p>Πρωτού εξηγήσουμε την βασική μεθοδολογία που ακολουθούμε στην main είναι σκόπιμο να κάνουμε μια σειρά παρατηρήσεων για το πρόβλημα</p>
<ul>
       <li>Κάνοντας iterate από το low μέχρι το high δεν χρειάζεται να ελέγχουμε με i++ εάν κάθε αριθμός είναι τέλειο τετράγωνο και ούτο καθεξής. Μια έξυπνη προσέγγιση θα ήταν να δημιουργούμε εμείς τα τέλεια τετράγωνα και πλέον να εξετάζομε μόνο εάν ο κατοπτρικός είναι τέλειος ή όχι. Αυτή η παρατήρηση επιβάλλει την δημιουργία μιας διαφορετικής επαναληπτικής δομής</li>
     <li>Δεν έχει νόημα να εξετάζουμε αριθμούς των οποίων η ρίζα είναι πολλαπλάσιο του 2, αφού προφανώς δεν θα είναι πρώτος αριθμός</li>
</ul>
<p>Γι' αυτό και μέσα στο while θα ελέγχουμε την συνθήκη i * i <= high και όλους τους ελέγχους θα τους κάνουμε για τον i * i. Ένα βήμα παραπέρα μπορούμε να ελέγχουμε την συνθήκη i <= sqrt(high) και πάλι να χειριζόμαστε τον i * i.  Η προσέγγιση αυτή επιβάλλει ενδεχομένως να επεξεργαστούμε λίγο την τιμή του low. Για παράδειγμα όταν μας δίνεται το εύρος [ 10 , 100 ], εμείς θα πρέπει κατά κάποιον τρόπο να διατρέξουμε τους αριθμούς 16 25 36 49 64 81 100. Το πρόβλημα λοιπόν ανάγεται στην εύρεση της τιμής εκκίνησης του while. Παρατηρούμε πως για να παράξουμε τους προηγούμενους αριθμούς αρκεί να υπολογίσουμε τα τετράγωνα των 4 5 6 7 8 9 10. Επομένως οι αριθμοί που θα πρέπει να διατρέξουμε θα είναι από  μικρότερο ακέραιο που είναι μεγαλύτερος από την ρίζα του low μέχρι και την ρίζα του high.</p>
Η επεξεργασία αυτή γίνεται ως εξής:

```c
// αλλαγή άνω ορίου
bound = sqrt(high); 
i  = ceil(sqrt(low));
if( i % 2 == 0)
{
     i++;
}
```
<p>
     Εφόσον θέλουμε να παράγουμε τα τέλεια τετράγωνα, αρκεί να ξεκινήσουμε το low από τον μικρότερο ακέραιο που είναι μεγαλύτερος από την ρίζα του low. Μπορούμε ακόμη να κάνουμε το κάτω όριο περιττό αριθμό με μια απλή if για να ελέγχουμε μόνο περιττούς, δεδομένου ότι το βήμα στην while που ακολουθεί είναι 2. 
</p>

H επαναληπτική διαδικασία εντός της main :

```c
// έναρξη βρόχου - έλεγχος συνθήκης επανάληψης
while (i <= bound) 
{
     j=i*i; // καταχώρηση  του i * i στην j για αποφυγή περιττών υπολογισμών
     a=mirror(j); // καταχώρηση  του mirror(j) στην α για αποφυγή περιττών υπολογισμών
     if(perf_mir(a) && is_prime(i) && j!=a) // έλεγχος βασικών συνθηκών
     {
          sum+=j; // προσαύξηση του sum κατά j
     }
     i+=2; // αύξηση του i κατά 2 για να αποφεύγουμε άρτια i
}
```
<p>Καθώς λοιπόν διατρέχουμε το while υπολογίζουμε εξαρχής το i * i και το αποθηκεύουμε σε μια βοηθητική μεταβλητή j την οποία αργότερα περνάμε ως παράμετρο στις συναρτήσεις μας. Παρομοίως πριν μπούμε στα if αποθηκεύουμε στην μεταβλητή a την κατοπτρική εικόνα του j, που είναι το i * i για να μην κάνουμε παραπάνω από το αναγκαίο υπολογισμούς. Ύστερα μπαίνουμε μέσα στο if και ελέγχουμε τρεις συνθήκες </p>

<ul>
   <li>perf_mir(a) --> Έλεγχος εάν το κατοπτρικό του j είναι τέλειο τετράγωνο με πρώτη ρίζα</li>  
   <li>is_prime(i) --> Έλεγχος εάν η ρίζα του j δηλαδή του i * i είναι πρώτος αριθμός(δεδομένου ότι η is_prime δέχεται ορίσματα ρίζες στην συνθήκ αυτή αρκεί το i ως όρισμα)</li>
   <li>j!=a --> Έλεγχος ότι το j δεν είναι ίσο με το κατοπτρικό του</li>  
</ul>
<p>Προσέξτε ότι η σειρά των συνθηκών μέσα στην if είναι κομβικής σημασίας. Μας είναι συμφέρον πάντοτε να μπαίνει πρώτη στην if η συνθήκη εκείνη που είναι τις λιγότερες φορές αληθής, προκειμένου να μην προχωράμε στον έλεγχο των επόμενων συνθηκών τζάμπα. Ύστερα από λίγο testing με διάφορα inputs κατέληξα στην παραπάνω σειρά των συνθηκών όπως φαίνεται μέσα στην if ή στην λίστα των συνθηκών παραπάνω.</p>

